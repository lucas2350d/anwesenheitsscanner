<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>QRâ€‘Anwesenheitsscanner</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.json" />
  <meta name="theme-color" content="#2196f3" />
  <link rel="icon" href="./logo.png" />
  <link rel="apple-touch-icon" href="./icon-192.png" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />

  <style>
    :root {
      --primary: #2196f3;
      --ok: #0a8;
      --warn: #d97706;
      --err: #b00;
      --bg: #f8f8f8;
    }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    main { margin: 0 auto; max-width: 960px; padding: 16px; }
    header { display:flex; align-items:center; gap:12px; margin-bottom: 12px; }
    header img { width:48px; height:48px; }
    h1 { margin: 0; font-size: 1.25rem; }
    #status { color:#444; display:block; margin-top:4px; }
    .net { display:flex; gap:8px; align-items:center; margin: 8px 0 16px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:.85rem; }
    .on { background:#e7f5ff; color:#0369a1; }
    .off { background:#fff4e5; color:#9a3412; }
    .pending { background:#eefce9; color:#166534; }
    .controls { display:flex; gap:8px; align-items:center; margin-bottom: 12px; }
    input[type="text"] {
      flex:1; padding: 10px 12px; border:1px solid #ccc; border-radius: 8px; font-size: 16px; background:white;
    }
    button {
      padding: 10px 14px; border: none; border-radius: 8px; background: var(--primary); color: white; font-size: 16px; cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    table { width:100%; border-collapse: collapse; background:white; border-radius: 8px; overflow: hidden; }
    th, td { padding:10px; border-bottom:1px solid #eee; text-align:left; }
    thead th { background:#f2f6ff; }
    .ok { color: var(--ok); font-weight: 600; }
    .warn { color: var(--warn); font-weight: 600; }
    .err { color: var(--err); font-weight: 600; }
    .hint { font-size: .9rem; color:#555; margin-top: 4px; }
    .muted { color:#777; }
    small time { font-variant-numeric: tabular-nums; }
  </style>
</head>
<body>
  <main>
    <header>
      <img src="./logo.png" alt="Vereinslogo" />
      <div>
        <h1>Anwesenheitsscanner Schwimmen</h1>
        <small id="status" aria-live="polite">Bereit</small>
      </div>
    </header>

    <div class="net" aria-live="polite">
      <span id="netBadge" class="badge on">Verbunden</span>
      <span id="qBadge" class="badge pending" hidden>Ausstehend: <b id="qCount">0</b></span>
      <small id="lastSyncWrap" class="muted" hidden>Letzte Synchronisierung: <time id="lastSync"></time></small>
    </div>

    <div class="controls">
      <input id="input" type="text" placeholder="ID scannen oder Name eingeben (z.â€¯B. Max Mustermann)" list="participants" autocomplete="off" autofocus />
      <datalist id="participants"></datalist>
      <button id="btn">Erfassen</button>
      <button id="btnSync" type="button" title="Ausstehende EintrÃ¤ge jetzt hochladen">Jetzt synchronisieren</button>
    </div>
    <p class="hint">
      ðŸ’¡ Tipp: QRâ€‘Codes sollten die <b>ID</b> enthalten. Namen kannst du tippen: <span class="muted">Vorname Nachname</span>.
    </p>

    <section>
      <table>
        <thead>
          <tr><th>ID / Name</th><th>Status</th><th>Zeit</th></tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </section>
  </main>

  <script>
    // ðŸ”— Apps Script Execâ€‘URL hier eintragen:
    // Beispiel: "https://script.google.com/macros/s/AKfycbx.../exec"
    const API_ENDPOINT = "https://script.google.com/macros/s/DEPLOYMENT_ID/exec";

    // Service Worker relativ registrieren (wichtig fÃ¼r GitHub Pages Unterpfad)
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./service-worker.js")
        .then(() => {
          console.log("âœ… Service Worker registriert");
          // Dem SW das Backend mitteilen (optional; Queue-Items enthalten die URL ohnehin)
          if (navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage({ type: "INIT", payload: { api: API_ENDPOINT } });
            // initialen Status abfragen
            navigator.serviceWorker.controller.postMessage({ type: "GET_STATUS" });
          }
        })
        .catch(err => console.error("SW Fehler:", err));
    }

    const $status   = document.getElementById("status");
    const $input    = document.getElementById("input");
    const $btn      = document.getElementById("btn");
    const $btnSync  = document.getElementById("btnSync");
    const $rows     = document.getElementById("rows");
    const $dl       = document.getElementById("participants");
    const $netBadge = document.getElementById("netBadge");
    const $qBadge   = document.getElementById("qBadge");
    const $qCount   = document.getElementById("qCount");
    const $lastSync = document.getElementById("lastSync");
    const $lastWrap = document.getElementById("lastSyncWrap");

    function setNetBadge() {
      const online = navigator.onLine;
      $netBadge.textContent = online ? "Verbunden" : "Offline";
      $netBadge.className = "badge " + (online ? "on" : "off");
    }
    setNetBadge();
    window.addEventListener("online", () => {
      setNetBadge();
      setStatus("Verbunden â€“ synchronisiereâ€¦");
      // Fallback-Sync (fÃ¼r Browser ohne Background Sync)
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({ type: "FLUSH" });
        navigator.serviceWorker.controller.postMessage({ type: "GET_STATUS" });
      }
    });
    window.addEventListener("offline", setNetBadge);

    // Teilnehmerliste laden (fÃ¼r Autocomplete)
    async function loadList() {
      try {
        setStatus("Lade Teilnehmerâ€¦");
        const url = new URL(API_ENDPOINT);
        url.searchParams.set("action", "list");
        const res = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
        const data = await res.json();
        if (!data.ok) throw new Error(data.message || "Fehler bei der Liste");
        $dl.innerHTML = "";
        for (const p of data.items) {
          const opt = document.createElement("option");
          opt.value = `${p.full} (${p.id})`;
          $dl.appendChild(opt);
        }
        setStatus(`Teilnehmer geladen: ${data.count}`);
      } catch (e) {
        console.warn(e);
        setStatus("Teilnehmerliste konnte nicht geladen werden (offline?)");
      }
    }

    function setStatus(text) { $status.textContent = text; }

    function parseQuery(raw) {
      const m = raw.match(/\(([^)]+)\)\s*$/);
      if (m) return { id: m[1] };
      const parts = raw.trim().split(/\s+/);
      if (parts.length === 1) return { id: parts[0] };
      return { vorname: parts[0], nachname: parts.slice(1).join(" ") };
    }

    async function tryOnlineMark(query) {
      const url = new URL(API_ENDPOINT);
      Object.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));
      // kurzer Timeout, damit wir offline schnell in die Queue fallen
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), 8000);
      try {
        const res = await fetch(url.toString(), {
          method: "GET",
          headers: { "Accept": "application/json" },
          signal: controller.signal
        });
        clearTimeout(t);
        const data = await res.json().catch(() => ({}));
        return data;
      } catch (e) {
        clearTimeout(t);
        throw e;
      }
    }

    function addRow(label, cls, statusText, t) {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${label}</td><td class="${cls}">${statusText}</td><td>${t}</td>`;
      $rows.prepend(tr);
    }

    async function enqueueForSync(query, label) {
      if (!navigator.serviceWorker.controller) {
        addRow(label, "err", "Keine SWâ€‘Steuerung", new Date().toLocaleTimeString());
        setStatus("Service Worker noch nicht aktiv â€“ bitte neu laden.");
        return;
      }
      navigator.serviceWorker.controller.postMessage({ type: "ENQUEUE", payload: { api: API_ENDPOINT, params: query } });
      setStatus("Offline gespeichert â€“ wird synchronisiert, sobald Verbindung da ist.");
      addRow(label, "warn", "Offline gespeichert", new Date().toLocaleTimeString());
      // Status nach dem Enqueue aktualisieren
      navigator.serviceWorker.controller.postMessage({ type: "GET_STATUS" });
    }

    async function handleSubmit() {
      const raw = $input.value.trim();
      if (!raw) return;
      const label = raw;
      const query = parseQuery(raw);
      $btn.disabled = true;
      setStatus("Erfasseâ€¦");

      const t = new Date().toLocaleTimeString();

      // 1) Versuche online
      try {
        const res = await tryOnlineMark(query);
        if (res && res.ok) {
          const statusTxt = res.code === "already_marked" ? "Bereits erfasst" : "Erfasst";
          addRow(label, "ok", statusTxt, t);
          setStatus(statusTxt);
        } else {
          // Backend erreichbar, aber fachlicher Fehler
          addRow(label, "err", res?.message || "Fehler", t);
          setStatus(res?.message || "Fehler");
        }
      } catch (_) {
        // 2) Offline/Timeout â†’ in Queue speichern
        await enqueueForSync(query, label);
      }

      $btn.disabled = false;
      $input.value = "";
      $input.focus();
    }

    $btn.addEventListener("click", handleSubmit);
    $input.addEventListener("keydown", (e) => { if (e.key === "Enter") handleSubmit(); });

    // Manuelle Synchronisation
    $btnSync.addEventListener("click", () => {
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({ type: "FLUSH" });
        navigator.serviceWorker.controller.postMessage({ type: "GET_STATUS" });
        setStatus("Synchronisiereâ€¦");
      }
    });

    // Nachrichten vom Service Worker (Queueâ€‘Status etc.)
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.addEventListener("message", (event) => {
        const msg = event.data || {};
        if (msg.type === "QUEUE_STATUS") {
          const pending = msg.pending || 0;
          if (pending > 0) {
            $qBadge.hidden = false;
            $qCount.textContent = String(pending);
          } else {
            $qBadge.hidden = true;
          }
          if (msg.lastSync) {
            $lastWrap.hidden = false;
            $lastSync.textContent = new Date(msg.lastSync).toLocaleString();
          }
          // Optionaler Textstatus
          if (msg.info) setStatus(msg.info);
        } else if (msg.type === "SYNC_DONE") {
          setStatus("Synchronisierung abgeschlossen");
        } else if (msg.type === "SYNC_PROGRESS") {
          setStatus(`Synchronisiereâ€¦ (${msg.done}/${msg.total})`);
        }
      });
    }

    // Initial
    loadList();
  </script>
</body>
</html>
